% 並列二分探索

クエリ処理のためのフレームワーク．

要素 $a[0\ldots n-1]$ に対して，$m$ 回の変更処理を行う．各処理は，$a$ の部分集合を選んで行う．

この処理に関して，次の形式のクエリに $q$ 回答える．
- 部分集合 $a'$ が条件 $P$ を満たさなくなるのは何回目の処理の直後か？

ただし，この $P$ は変更処理に対して単調とする．
すなわち，ある部分集合 $a'$ に対して，$i$ 回目の処理の直後に初めて $P(a')$ が満たさなくなったとき，それ以降の処理の直後でも $P(a')$ は満たさないとする．

典型的には，次のような問題が挙げられる：
> 頂点集合 $\{0, 1, \dots, n-1\}$ に対して，$i$ 回目の処理では $u_i$ と $v_i$ を辺で結ぶ．
> 頂点集合 $s_j$ と $t_j$ が連結になるのは何回目の処理の直後か？

https://atcoder.jp/contests/code-thanks-festival-2017/tasks/code_thanks_festival_2017_h

## 方法

配列 $l[0\ldots q-1]$ と $u[0\ldots q-1]$ を用意する．初め，$l$ の各要素は $-1$ で，$u$ の各要素は $m+1$ で初期化しておく．

- $a$ を初期化し，$m$ 回の変更処理を進めていく．
- $i$ 回目の処理の直前に，$\lfloor (l[j]+u[j])/2\rfloor = i$ なる各 $j$ について $l[j]$ または $u[j]$ を更新する．
  - $j$ 個目のクエリに関して条件が成り立っていれば $l[j]$ を，そうでなければ $u[j]$ を $i$ で更新する．
  - $j$ を探すのは，適切なデータ構造を用いて定数時間で行う．

この処理を，$u[j]-l[j] > 1$ なる $j$ が存在する限り行う．$\log_2(m)+O(1)$ 回行う必要がある．

処理を終えた後，$u[j]$ が $j$ 番目のクエリに対する答えである．ただし，$u[j] = 0$ のとき，最初から条件が満たされないことを，$u[j] = m+1$ のとき，最後まで条件が満たされることをそれぞれ意味する．
