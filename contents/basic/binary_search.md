% 二分探索 (1)

昇順に並んだ配列 $a[0\ldots n-1]$ があり，ある値 $x$ が $a$ に含まれるか（含まれるならその最初の添字）を答える問題を考える．
先頭から順に見ていくことを愚直に行うと $O(n)$ 時間かかる．

まず，$a$ は $a_i < x$ である区間と $a_i \ge x$ である区間に二分されることに注意する（ただし，片方が空になることもある）．

ここで，$l \gets 0$, $r \gets n$ として $[l, r)$ の中間 $m \gets \lfloor (l+r) / 2 \rfloor$ を考える．
ここでの値 $a_m$ について，$a_m < x$ であれば，二分の境界は $[m, r)$ にあることがわかり，そうでなければ $[l, m)$ にあることがわかる．
これを $r-l = 1$ になるまで繰り返す．
$[0, k)$ と $[k, n)$ に二分されるとき，$r = k$ となる．

上の問題設定においては，以下が答えとなる．
- `yes`, $k$ if $a_k = x$
- `no` otherwise

長さ $i$ の区間は，一回の操作でたかだか $\lfloor i/2\rfloor$ になるため，$\log_2 n+O(1)$ 時間で終了する．

---

C++/STL においては，$a_i \ge x$ および $a_i > x$ となる境界（境界の右側で成り立つとする）を求める関数 `std::lower_bound`, `std::upper_bound` が用意されている．
また，両方をまとめて求める関数 `std::equal_range` もある．

実際にはソートされている必要はなく，単に二分されていればよい．
たとえば，配列 `[1, 4, 2, 5, 9, 7, 6]` から `5` をこのアルゴリズムで探すことは問題ない．
